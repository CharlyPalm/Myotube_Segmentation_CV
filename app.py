import tkinter as tk
from tkinter import filedialog
from tkinter import messagebox
from PIL import Image, ImageTk
import numpy as np
import cv2
import os
from pathlib import Path
import time
# Código basado en la implementación de Ultralytics YOLOv11 # Fuente: https://github.com/ultralytics/yolov11

# Load the YOLOv11 model
from ultralytics import YOLO

# Load the pre-trained model
model = YOLO(r"models\runs\segment\train2\weights\best.pt")

def read_polygon_from_txt(txt_path, img_width, img_height):
    """Reads polygon coordinates from the TXT file generated by YOLO and scales them to the image dimensions."""
    polygons = []
    try:
        with open(txt_path, 'r') as file:
            lines = file.readlines()
            for line in lines:
                # Extract the polygon coordinates (assuming they are X, Y values)
                coordinates = line.strip().split()[1:]  # Ignore the class and confidence
                coordinates = [float(coord) for coord in coordinates]  # Convert coordinates to float
                
                # The coordinates are in the form [X1, Y1, X2, Y2, ..., Xn, Yn], so we group them
                polygon = list(zip(coordinates[::2], coordinates[1::2]))  # Group X and Y
                
                # Scale the coordinates to the image dimensions
                scaled_polygon = [(int(x * img_width), int(y * img_height)) for x, y in polygon]
                polygons.append(scaled_polygon)
    except Exception as e:
        print(f"Error reading the TXT file: {e}")
    return polygons

def generate_obb(points):
    """
    Generates an Oriented Bounding Box (OBB) for a set of points.

    Args:
        points (np.ndarray): Array of points that define the polygon (Nx2).

    Returns:
        rect (cv2.RotatedRect): Rotated rectangle representing the OBB.
    """
    points = np.array(points)
    rect = cv2.minAreaRect(points)
    return rect

def find_latest_predict_folder(base_dir):
    """
    Finds the latest 'predict#' folder within the base directory.
    Ensures that the search occurs after a small delay.
    """
    # List all folders that start with 'predict'
    predict_folders = [f for f in os.listdir(base_dir) if f.startswith("predict")]
    
    # Filter only folders that have a valid number after 'predict'
    valid_predict_folders = []
    for folder in predict_folders:
        try:
            folder_number = int(folder.replace("predict", ""))
            valid_predict_folders.append((folder_number, folder))
        except ValueError:
            continue
    
    # Sort the valid folders by number (descending)
    valid_predict_folders.sort(key=lambda x: x[0], reverse=True)
    
    # Get the latest valid folder
    if valid_predict_folders:
        latest_folder = os.path.join(base_dir, valid_predict_folders[0][1])
        # Wait for a moment to ensure that the prediction files are ready
        time.sleep(0.5)  # Wait half a second (adjust as needed)
        print(f"Found the most recent prediction folder: {latest_folder}")
        return latest_folder
    else:
        return None

def find_latest_txt_file(labels_folder):
    """
    Finds the most recent .txt file in the labels folder.
    """
    txt_files = [f for f in os.listdir(labels_folder) if f.endswith('.txt')]
    
    if not txt_files:
        return None
    
    # Get the full paths of the .txt files
    txt_files_paths = [os.path.join(labels_folder, f) for f in txt_files]
    
    # Get the most recent file based on modification date
    latest_txt_file = max(txt_files_paths, key=os.path.getmtime)
    
    print(f"Found the most recent TXT file: {latest_txt_file}")
    return latest_txt_file

def predict(image_path):
    """Predicts and draws polygons and OBBs on the image."""
    img = cv2.imread(image_path)
    
    if img is None:
        print(f"Error: Could not load the image from {image_path}")
        return None
    
    print(f"Image loaded successfully from {image_path}")
    
    try:
        # Define a base directory to save the results
        custom_save_dir = "models/runs/segment/"  # Change this to the base path where you want to save the results
        
        # Perform the prediction with YOLO
        results = model(image_path, save_txt=True, save_dir=custom_save_dir, conf=0.05, iou=0.01)

        # Check if any masks were found in the results
        found_masks = False
        for r in results:
            if r.masks is None:
                found_masks = False
            else:
                found_masks = True
                print(r.masks)  # This will keep showing the masks if there are any

        # If no masks were found, show a warning message
        if not found_masks:
            messagebox.showinfo("Warning", "No masks were found in the predicted image.")
            return None

        # Find the most recent prediction folder
        latest_predict_folder = find_latest_predict_folder(custom_save_dir)  # Use the base prediction directory
        
        if latest_predict_folder is None:
            print("No recent prediction folder found.")
            return None
        
        # Get the labels folder path
        labels_path = os.path.join(latest_predict_folder, "labels")
        
        # Find the most recent .txt file in the labels folder
        latest_txt_file = find_latest_txt_file(labels_path)
        
        if latest_txt_file is None:
            print("No recent .txt file found in the labels folder.")
            return None
        
        # Get the image dimensions
        img_height, img_width, _ = img.shape
        
        # Read the polygons from the most recent .txt file and scale them
        polygons = read_polygon_from_txt(latest_txt_file, img_width, img_height)
        
        # Check if any polygons were found
        if not polygons:
            print("No polygons found in the TXT file.")
            return None

        # Convert the original image to RGB
        img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
        
        # Draw the polygons and OBBs on the image
        for polygon in polygons:
            points = np.array(polygon, np.int32)
            points = points.reshape((-1, 1, 2))
            img_rgb = cv2.polylines(img_rgb, [points], isClosed=True, color=(0, 255, 0), thickness=2)  # Green polygon
            
            # Generate the Oriented Bounding Box (OBB)
            rect = generate_obb(polygon)
            
            # Draw the OBB on the image
            box = cv2.boxPoints(rect)
            box = np.int0(box)
            img_rgb = cv2.polylines(img_rgb, [box], isClosed=True, color=(255, 0, 0), thickness=2)  # Red OBB

        # Convert the image with polygons and OBBs to a format that Tkinter can handle
        img_with_polygons_pil = Image.fromarray(img_rgb)
        
        # Adjust the image size to the window
        window_width = root.winfo_width()
        window_height = root.winfo_height()
        
        # Adjust the image to the window dimensions
        img_with_polygons_pil = img_with_polygons_pil.resize((window_width, window_height), Image.Resampling.LANCZOS)
        
        img_with_polygons_tk = ImageTk.PhotoImage(img_with_polygons_pil)

        return img_with_polygons_tk

    except Exception as e:
        print(f"Error during prediction: {e}")
        return None


# Function to open an image from the file system
def open_image():
    file_path = filedialog.askopenfilename(title="Open Image", filetypes=[("Image Files", "*.jpg;*.png")])
    if file_path:
        # Perform prediction and get the image with polygons and OBB
        result_img_tk = predict(file_path)
        
        if result_img_tk:
            # Display the image with segmented polygons and OBBs
            label_img_mask.config(image=result_img_tk)
            label_img_mask.image = result_img_tk
        else:
            messagebox.showerror("Error", "Could not perform the prediction")

# Create the interface with Tkinter
root = tk.Tk()
root.title("Prediction with YOLOv11")

# Set the initial size of the window
root.geometry("1000x700")

# Button to load an image
btn_open = tk.Button(root, text="Load Image", command=open_image)
btn_open.pack()

# Label to display the image with polygons and OBBs
label_img_mask = tk.Label(root)
label_img_mask.pack(fill=tk.BOTH, expand=True)

# Start the interface
root.mainloop()
